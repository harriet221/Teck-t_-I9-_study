운영체제에 대해 다뤘던 주제들을 연결한 OS 총정리 QnA

<br>

> **_OS란 무엇인가?_**

## OS (운영체제)

: 컴퓨터 시스템 운영 소프트웨어

<br><br>

> **_OS는 주로 무슨 일을 하는가?_**

## OS 주요 역할

- 자원 관리
- 프로세스 관리
- 메모리 관리
- 파일 시스템 관리
- 사용자 인터페이스 제공
- 보안 및 권한 관리

특히 다음의 두 역할은 긴밀히 맞물려 있다.

1. 자원 관리: 운영체제는 시스템의 하드웨어 자원(프로세스, 메모리, 저장 장치, 입출력 장치 등)을 효율적으로 할당하고 관리한다.

2. 프로세스 관리: 프로세스를 생성, 스케줄링 및 제어하여 다중 작업 환경을 제공한다.

<br><br>

> **_응용 프로그램(어플리케이션)은 무엇을 통해 운영체제의 이러한 서비스를 요청하는가?_**

## 시스템 콜

: 사용자 / 응용 프로그램이 운영체제의 핵심 부분에 위치한 커널에게 특정 기능 또는 서비스를 요청하기 위해 사용하는 인터페이스.

운영체제의 커널은 부팅과정에서 전체 메모리 리소스 중에 일정 부분을 점유하여 동작하고 인터럽트 등 모든 하드웨어에 접근할 수 있다. 그러나 응용 프로그램은 커널이 제공하는 자원을 사용하며, CPU에 대한 권한수준이 사용자 공간(user space)에서 동작하며 특정한 기계어 명령어 실행이 불가능하다. 따라서 응용 프로그램이 파일 시스템을 사용하는 등 기타 여러 상황에서 커널에 의존해야만 한다. 이때 응용 프로그램에서 커널의 서비스를 사용하는 방법이 시스템 호출이다.

시스템 콜은 주로 응용 프로그램이 하드웨어와 상호 작용하거나 운영체제에서 제공하는 서비스에 접근하기 위해 사용하며, 이때 각각의 작업은 해당하는 시스템 콜을 호출하여 커널에게 요청된다. 시스템 콜은 주로 다음과 같은 유형으로 분류한다.

- 프로세스 제어(process control)
- 파일 조작(file manipulation)
- 장치 관리(device management)
- 정보 유지(information maintenance)
- 통신(communication)

<br><br>

> **_프로세스 관리는 왜 필요한가?_**

: 메모리는 한정되어 있고, 여러 프로세스가 돌아감에 따라, 프로세스 간 공유하거나 각자 독점하고 있는 메모리가 있기 떄문에.

## 프로세스 주소 공간

= 프로세스가 메모리 내에서 사용하는 가상 메모리 공간

여러 프로세스는 병렬적으로 혹은 동시에 작업하게 되며, 한 프로세스 안에서도 여러 스레드가 동시에 작업하게 된다. 이에 프로세스는 최대한 데이터를 공유하면서 메모리의 전체 사용량을 줄이기 위해 따로 주소 공간을 구분하여 할당받게 된다.

### 프로세스 간 독립 + 스레드 간 공유 주소공간

- Code 영역: 코드 자체를 구성하는 메모리
- Data 영역: 전역변수, 정적변수(static), 배열 등 초기화 된 데이터
- BSS 영역: 초기화 전의 데이터
- Heap 영역: 동적 할당 관련 데이터
- 메모리 매핑 영역: 파일 I/O, 공유 라이브러리 등 매핑 및 읽고 쓰기 관련 데이터

### 한 프로세스 내 스레드 간 독립 주소공간

- Stack 영역: 지역변수, 매개변수, 리턴 값 등 함수 호출 및 복귀, 지역변수 관련 정보를 저장하는 임시 메모리
  : 스레드 간 독립적인 동작 수행을 위해 Stack Segment는 따로 할당한다.

<br><br>

> **_각 프로세스는 어떻게 관리되는가?_**

: 동작하고 있는 프로그램이 여러개일 때, CPU는 다양한 스케줄링 기법을 통해 각 프로세스의 작업을 관리한다.

## CPU 스케줄링

: 자원을 효율적으로 사용 & 프로세스 간 충돌 방지

- 기본적인 목표 : 오버헤드 ↓ / 사용률 ↑ / 기아 현상 ↓

여러 프로세스가 CPU를 사용하기 위해 경쟁할 때 어떤 프로세스가 CPU를 할당받을지를 결정하는 작업이다. 운영체제는 CPU 스케줄링 알고리즘을 통해 프로세스를 효율적으로 관리하고, 시스템의 성능을 최적화하기 위해 다양한 방식으로 CPU를 할당한다.

다양한 알고리즘과 규칙으로 구성된 스케줄링 정책들이 사용되고 있으며, 각각의 시스템에서 어떤 스케줄링 정책이 사용되는지는 그 시스템의 특성과 요구사항에 따라 다르나, 일반적으로 선호하는 스케줄링 정책은 이렇다.

| 시스템 환경 | 선점(Preemptive)                                     | 비선점(Non-preemptive)           |
| ----------- | ---------------------------------------------------- | -------------------------------- |
| 일괄처리    | Round Robin                                          | FCFS / SJF / Priority Scheduling |
| 대화형      | Round Robin / Priority Scheduling / Multilevel Queue | X                                |
| 실시간      | Earliest Deadline First (EDF)                        | X                                |

- 선점 (preemptive) :
  프로세스가 CPU를 할당받아 실행 중일 때, 또 다른 높은 우선순위의 프로세스가 도착하면 실행 중인 프로세스를 중단하고 우선순위가 높은 프로세스에게 CPU를 할당하는 방식이다. 해당 우선순위는 동적이며, OS가 다른 프로세스의 사용중에 CPU의 사용권을 강제 회수할 수 있어, 처리시간을 예측하기 어렵다.

- 비선점 (nonpreemptive) :
  프로세스가 CPU를 할당받아 실행 중일 때, 다른 프로세스가 도착하더라도 현재 실행 중인 프로세스를 중단시키지 않고 그대로 끝까지 실행하는 방식으로, 일괄처리 시스템에서 주로 사용한다. 프로세스가 종료되거나 I/O 등의 이벤트가 있을 때까지 실행을 보장하기에 처리시간을 예측하기 용이하다.

<br><br>

> **_스케줄링에서 다음에 수행할 프로세스의 정보는 어디에서 얻는가?_**

: 각 프로세스 정보, Process Metadata는 PCB에 따로 저장된다.

## PCB (Process Control Block)

운영 체제에서 프로세스를 관리하기 위한 자료구조로, 각 프로세스에 대한 정보를 저장하고, 이를 통해 프로세스의 상태 및 동작을 추적하는 데 사용한다. 프로세스가 생성되고 주소 공간이 할당되면, 해당 프로세스의 메타데이터들이 PCB에 저장된다.

: PCB는 운영 체제 커널 내에서 관리되며, 각 프로세스에 대한 정보를 저장하여 프로세스 스케줄링 및 관리 작업에 사용한다. 이렇게 수행 중인 프로세스를 변경할 때, CPU의 레지스터 정보가 변경되는 것을 *Context Switching*이라고 한다.

### Context Switching

: CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정이다. Ready → Running, Running → Ready, Running → Waiting 등 *프로세스 상태가 변경*될 시 진행하는 과정이다.

### 프로세스 상태 변화 / 전이

승인 (Admitted) : 프로세스 생성(New) 승인

스케줄러 디스패치 (Scheduler Dispatch) : 준비(Ready) 상태에 있는 프로세스 중 하나를 선택하여 실행(Running)

_인터럽트_ (Interrupt) : 예외, 입출력, 이벤트 등 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우, 현재 실행(Running) 중인 프로세스를 중단하여 준비(Ready) 상태로 바꾸고, CPU에게 발생된 상황에 대한 우선 처리를 요구하여 해당 작업 먼저 처리

입출력 또는 이벤트 대기 (I/O or Event wait) : 실행(Running) 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기(Waiting) 상태로 전환

입출력 또는 이벤트 완료 (I/O or Event Completion) : 입출력/이벤트가 끝난 프로세스를 준비(Ready) 상태로 전환

<br><br>

> **_인터럽트는 왜 발생하는가?_**

## 인터럽트

: 컴퓨터 시스템에서 발생하는 이벤트 혹은 신호

인터럽트는 컴퓨터 시스템이 다양한 작업을 효과적으로 처리하면서도 신속한 응답성을 유지하고, 그 와중에 필연적으로 발생하는 예외 상황을 처리하는 데 필수적인 메커니즘으로, 컴퓨터 시스템의 안정성, 신뢰성 및 다중 작업에 대한 성능 향상에 기여한다.

→ 특정한 어떤 일을 할 시기를 알기 위해 컨트롤러가 계속 관련된 작업을 체크하는 폴링(Polling) 중에는 원래 하던 일에 집중할 수가 없게 되어 전체적인 작업 효율이 떨어진다. 그러한 단점에 대한 대응으로, MCU(마이크로컨트롤러 장치) 자체가 하드웨어적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식을 취하는 것이 인터럽트 방식이다. 이는 폴링에 비해 신속하게 대응할 수 있어, 실시간 대응에 필수적이다. => 이벤트 기반 + 비동기적 = 자원효율적

- 하드웨어 인터럽트: CPU의 하드웨어 신호에 의해 발생
  - 내부 인터럽트(= Trap): 잘못된 명령이나 데이터의 사용에 의해 발생
  - 외부 인터럽트: 입출력 장치, 타이밍 장치, 전원 등의 외부적 요인으로 발생
- 소프트웨어 인터럽트: 명령어의 수행에 있어, 프로그램 처리 중 명령의 요청에 의해 발생

<br><br>

> **_프로세스 간에는 어떻게 통신하는가?_**

## IPC

: 프로세스 간 통신

프로세스는 각각의 주소공간을 할당받아 상호 독립적으로 실행된다. 그러나 서로 독립적으로 실행되는 프로세스 간에도 통신이 필요한 경우가 있을 수 있다. 이때 각 프로세스는 커널이 제공하는 다양한 IPC 설비를 이용해 다른 프로세스와 통신을 주고받을 수 있다.

- 익명 Pipe
  : 부모 프로세스와 자식 프로세스 사이에서 단방향 통신을 제공하는 메커니즘. 부모 프로세스가 파이프를 생성하고, 자식 프로세스에게 상속하여 통신함. 부모 자식처럼 통신할 프로세스를 명확히 알 수 있는 경우에 사용. 해당 두 개의 프로세스를 연결하는데, 한쪽 방향으로만 통신이 가능한 반이중 통신. 따라서 양방향 송수신을 하고 싶으면 2개의 파이프 필요.

- Named PIPE(FIFO)
  : (익명) 파이프 방식의 응용. 파일 시스템에 이름이 부여된(Named) 파이프로, 파일 시스템에서 특정 경로에 파일처럼 파이프가 생성되고 이름이 부여되어, 다른 프로세스는 이름을 통해 해당 파이프에 접근할 수 있음. 서로 모르는 상태의 프로세스들 사이 반이중 통신 가능.

- Message Queue
  : 프로세스 간에 메시지를 주고받을 수 있는 큐. 데이터의 순서가 보장되며, 각각의 메시지에는 타입 지정 가능. 이름 대신 특정 키 값으로 식별. 다른 프로세스가 해당 키 값을 알고 있다면 접근 가능함. 즉, 사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있음.

- 공유 메모리
  : 두 개 이상의 프로세스가 동일한 물리적 메모리 공간을 공유하게 해주는 메커니즘. 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당, 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 함. 이를 통해 한 프로세스에서 변경한 데이터를 다른 프로세스에서 읽을 수 있으며, 중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 가장 빠르게 작동.

- 메모리 맵
  주로 파일로 대용량 데이터를 공유해야 할 때나, I/O와 데이터 공유를 위해 사용하는 방법. IPC에서도 응용해서 사용. 공유 메모리처럼 메모리를 공유해준다. 메모리 맵은 열린 파일을 메모리에 맵핑시켜서 공유하는 방식이다. (즉 공유 매개체가 파일+메모리)

- 소켓
  네트워크를 통해 프로세스 간에 데이터를 공유하는 방법. 주로 TCP/IP 기반의 네트워크 상에서 프로세스 간 통신을 지원. 클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유해야 할 때 사용.

<br><br>

> => 컴퓨터는 한번에 한가지 일만 처리하지 않는다. 이러한 컴퓨터의 multitasking(multiprocessing) 작업에서 가장 중요한 것은 여러 어플리케이션이 동시에 실행되면서도 서로 간섭하지 않고 한정된 자원을 효율적으로 사용하는 것이다. 다만 CPU의 효율적인 사용을 위해, 즉 CPU가 놀지 않도록 하고, 사용자에게 빠르게 작업 결과를 제공해주기 위해 어느정도의 오버헤드는 감수할 필요 또한 있다. 이에 다중 작업에서의 CPU 스케쥴링과 공유 자원 관리, 인터럽트 등에서 발생하는 지연과 에러 처리, 그리고 시스템 전체의 보안을 관리하는 운영체제의 존재는 필수적이다.
