# HTTP & HTTPS

<br>

## 1. HTTP(HyperText Transfer Protocol)

인터넷 상에서 클라이언트와 서버가 데이터를 주고 받기 위한 표준 프로토콜(통신 규약)

: 클라이언트-서버 모델을 기반으로 하며, 웹 브라우저와 웹 서버 간에 정보를 주고받을 때 사용함.

<br>

→ HTTP는 텍스트 교환 방식. 데이터를 전송할 때 암호화나 디지털 서명과 같은 보안 기능을 제공하지 않기 때문에, 네트워크에서 신호를 가로챘을 때 내용이 그대로 노출되는 보안 이슈 존재 + 데이터 무결성 보장X

그 해결책 = **HTTPS**

<br>

## 2. HTTPS(HyperText Transfer Protocol Secure)

인터넷 상에서 정보를 암호화하는 **SSL / TLS 프로토콜**을 사용해 약점을 보완한 HTTP

SSL은 "Secure Socket Layer"의 약자로, 보안 소켓 레이어 프로토콜 의미. 웹 서버와 브라우저 간의 안전한 데이터 전송을 위한 표준 보안 프로토콜 중 하나. 최근에는 더 안전한 Transport Layer Security (TLS) 프로토콜이 SSL을 대체하는 추세.

SSL / TLS는 통신 경로를 암호화하여 제3자로부터의 데이터 도용, 감청, 변경 등을 방지함. HTTP의 텍스트를 대칭키 및 공개키 암호화를 사용하여 보호하고, 디지털 인증서를 통해 통신 상대방의 신원을 확인함. 즉, HTTPS는 공인된 인증 기관(Certificate Authority, CA)에서 발급된 SSL / TLS 인증서를 설치한 웹 서버에서만 구현 가능하며, 이를 통해 사용자의 브라우저는 해당 웹 사이트의 신뢰성을 확인할 수 있음.

<br>

## 3. HTTPS 흐름

1. 서버에 HTTPS를 적용하기 위해 서버측에서 공개키와 비공개키를 생성함.

2. 신뢰할 수 있는 CA 기업을 선택하고, 그 기업에게 해당 서버의 공개키 관리에 대한 계약을 맺음.

3. 계약 후 CA 기업은 해당 기업의 정보, 서버 공개키, 공개키 암호화 방법을 담은 디지털 인증서를 생성, 해당 인증서를 CA 기업의 비공개키로 암호화해서 서버에게 제공함.

4. 서버는 암호화된 디지털 인증서를 소지하게 됨. 이후 클라이언트가 서버에 접속하여 서버에 요청이 오면, 서버는 인증서를 클라이언트에게 전달함. (3-way handshake 진행중)

5. 클라이언트는 서버의 정보를 CA 기업의 비공개키로 암호화한 인증서를 받게 됨.

6. 이때, 신뢰할 수 있는 CA 기업의 공개키는 브라우저에 이미 내장되어 있기 때문에, 별다른 조치 없이도 브라우저가 인증서를 탐색하여 복호화 가능함. 브라우저는 이를 복호화하여 서버의 공개키를 획득함.

7. 클라이언트가 서버와 HandShaking 과정에서 주고받은 난수를 조합하여 pre-master-secret-key 를 생성한 뒤, 서버의 공개키로 해당 대칭키를 암호화하여 서버로 전송함.

8. 서버는 암호화된 대칭키를 자신의 비공개키로 복호화하여 클라이언트와 동일한 대칭키를 획득함.

9. 클라이언트와 서버는 각자 생성한 pre-master-secret-key를 master-secret-key으로 변환함.

10. master-secret-key 를 통해 session-key를 생성하고 이를 이용하여 대칭키 방식으로 통신함. 각 통신이 종료될 때마다 session-key는 파기함.

<br>

### HTTPS도 무조건 안전한 것은 X

→ 대표적인 인증 기관(CA)으로는 Let's Encrypt, DigiCert, Comodo, GlobalSign, Symantec 등이 있지만, 이처럼 신뢰받는 CA 기업이 아닌 자체적으로 인증서를 발급한 경우 보안 위협 있을 수 있음. 이때는 브라우저에서 해당 보안 정책에 따라 `주의 요함`, `안전하지 않은 사이트`와 같은 경고 알림이 브라우저의 내부 보안 메커니즘에 의해 자동으로 활성화됨.
